<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Barrier.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Transportation</a> &gt; <a href="index.source.html" class="el_package">fr.ufc.l3info.oprog</a> &gt; <span class="el_source">Barrier.java</span></div><h1>Barrier.java</h1><pre class="source lang-java linenums">package fr.ufc.l3info.oprog;

import java.util.Map;

/**
 * La classe Barrier représente une barrière de contrôle d'accès dans un réseau de métro.
 */
public class Barrier {

    // Réseau de métro associé à cette barrière
    final private Network associatedNetwork;

    // Nom de la station où se trouve cette barrière
    final private String stationName;

    // Structure de tarification associée à cette barrière
    final private Map&lt;Double, Integer&gt; tariffStructure;

    /**
     * Constructeur privé pour créer une instance de Barrier.
     *
     * @param associatedNetwork Le réseau de métro associé
     * @param stationName       Le nom de la station
     * @param tariffStructure   La structure de tarification
     */
<span class="fc" id="L26">    private Barrier(Network associatedNetwork, String stationName, Map&lt;Double, Integer&gt; tariffStructure) {</span>
<span class="fc" id="L27">        this.associatedNetwork = associatedNetwork;</span>
<span class="fc" id="L28">        this.stationName = stationName;</span>
<span class="fc" id="L29">        this.tariffStructure = tariffStructure;</span>
<span class="fc" id="L30">    }</span>

    /**
     * Méthode statique pour instancier un objet Barrier en vérifiant la validité des paramètres.
     *
     * @param associatedNetwork Le réseau de métro
     * @param stationName       Le nom de la station
     * @param tariffStructure   La structure de tarification
     * @return Une instance de Barrier si les paramètres sont valides, sinon null
     */
    public static Barrier build(Network associatedNetwork, String stationName, Map&lt;Double, Integer&gt; tariffStructure) {
        // Vérifications de base
<span class="pc bpc" id="L42" title="5 of 12 branches missed.">        if (associatedNetwork == null || stationName == null || tariffStructure == null || !associatedNetwork.isValid() || associatedNetwork.getStationByName(stationName) == null || tariffStructure.isEmpty()) {</span>
<span class="fc" id="L43">            return null;</span>
        }

        // Vérification des prix
<span class="fc bfc" id="L47" title="All 2 branches covered.">        for (Map.Entry&lt;Double, Integer&gt; entry : tariffStructure.entrySet()) {</span>
<span class="pc bpc" id="L48" title="2 of 6 branches missed.">            if (entry.getKey() &lt; 0 || entry.getValue() &lt;= 0 || entry.getValue() % 10 != 0) {</span>
<span class="fc" id="L49">                return null;</span>
            }
<span class="fc" id="L51">        }</span>

        // Vérification de la présence d'un tarif pour la distance 0
<span class="pc bpc" id="L54" title="1 of 2 branches missed.">        if (!tariffStructure.containsKey(0.0)) {</span>
<span class="nc" id="L55">            return null;</span>
        }

<span class="fc" id="L58">        return new Barrier(associatedNetwork, stationName, tariffStructure);</span>
    }

    /**
     * Méthode pour entrer dans le réseau de métro.
     *
     * @param providedTicket Le ticket utilisé pour l'entrée
     * @return true si l'entrée est autorisée, sinon false
     */
    public boolean enter(ITicket providedTicket) {
        // Vérifications de base pour l'entrée
<span class="pc bpc" id="L69" title="2 of 8 branches missed.">        if (providedTicket == null || !providedTicket.isValid() || providedTicket.getEntryStation() != null || providedTicket.getAmount() &lt;= 0) {</span>
<span class="fc" id="L70">            return false;</span>
        }

        // Enregistrement de la station d'entrée sur le ticket
<span class="fc" id="L74">        providedTicket.entering(this.stationName);</span>
<span class="fc" id="L75">        return true;</span>
    }

    /**
     * Méthode pour sortir du réseau de métro.
     *
     * @param providedTicket Le ticket utilisé pour la sortie
     * @return true si la sortie est autorisée, sinon false
     */
    public boolean exit(ITicket providedTicket) {
        // Vérifications de base pour la sortie
<span class="pc bpc" id="L86" title="2 of 6 branches missed.">        if (providedTicket == null || !providedTicket.isValid() || providedTicket.getEntryStation() == null) {</span>
<span class="fc" id="L87">            return false;</span>
        }

        // Calcul du coût du trajet
<span class="fc" id="L91">        double shortestDistance = associatedNetwork.distance(providedTicket.getEntryStation(), this.stationName);</span>
<span class="fc" id="L92">        int adultFare = calculateFareForDistance(shortestDistance);</span>
<span class="fc" id="L93">        int childFare = (int) Math.ceil(adultFare / 2.0);</span>

        // Vérification du solde du ticket
<span class="fc bfc" id="L96" title="All 2 branches covered.">        if (providedTicket.isChild()) {</span>
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">            if (providedTicket.getAmount() &gt;= childFare) {</span>
<span class="fc" id="L98">                providedTicket.invalidate();</span>
<span class="fc" id="L99">                return true;</span>
            }
        } else {
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">            if (providedTicket.getAmount() &gt;= adultFare) {</span>
<span class="fc" id="L103">                providedTicket.invalidate();</span>
<span class="fc" id="L104">                return true;</span>
            }
        }

<span class="nc" id="L108">        return false;</span>
    }

    /**
     * Calcule le tarif associé à une distance parcourue en utilisant la structure de tarification.
     *
     * @param traveledDistance La distance parcourue par l'usager.
     * @return Le tarif associé à cette distance.
     */
    private int calculateFareForDistance(double traveledDistance) {

        // Étape 1 : Convertir l'ensemble des clés (distances) de la structure de tarification en un flux (stream).
        // Ceci permet d'effectuer des opérations en chaîne sur cet ensemble.
        // Étape 2 : Filtrer le flux pour ne conserver que les distances inférieures ou égales à la distance parcourue.
        // Étape 3 : Trouver la plus grande distance parmi celles filtrées. Cette distance sert de seuil pour définir le tarif.
<span class="fc" id="L123">        Double key = tariffStructure.keySet().stream()</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">                .filter(distance -&gt; distance &lt;= traveledDistance)</span>
<span class="fc" id="L125">                .max(Double::compareTo)</span>
<span class="fc" id="L126">                .orElse(null);</span>

        // Étape 4 : Renvoyer le tarif associé à la distance/seuil trouvée.
        // Si aucune distance correspondante n'est trouvée, renvoyer une valeur par défaut (ici, Integer.MAX_VALUE).
<span class="pc bpc" id="L130" title="1 of 2 branches missed.">        return key != null ? tariffStructure.get(key) : Integer.MAX_VALUE;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>